using System.Reflection;
using System.Runtime.Loader;
using Microsoft.Extensions.DependencyModel;
using Microsoft.Extensions.DependencyModel.Resolution;

namespace Havit.Data.EntityFrameworkCore.CodeGenerator.Tool;

public class DependencyContextAssemblyLoader
{
	private readonly DependencyLoadInfo _buildLoadInfo;
	private readonly DependencyLoadInfo _projectAssetLoadInfo;

	public DependencyContextAssemblyLoader(
		DependencyContext buildOutputDependencyContext,
		DependencyContext projectAssetsContext,
		string appBasePath)
	{
		_buildLoadInfo = new DependencyLoadInfo(buildOutputDependencyContext, appBasePath);
		_projectAssetLoadInfo = new DependencyLoadInfo(projectAssetsContext, appBasePath);
	}

	public void RegisterResolvingEvent(AssemblyLoadContext assemblyLoadContext)
	{
		assemblyLoadContext.Resolving += ResolveAssembly;
	}

	private Assembly ResolveAssembly(AssemblyLoadContext assemblyLoadContext, AssemblyName assemblyName)
	{
		var compilationLibrary = _projectAssetLoadInfo.FindCompilationLibrary(assemblyName);

		// DependencyContext loaded from <assembly>.deps.json (in bin directory) does not contain all assemblies from references packages,
		// so we cannot use it for resolving these assemblies.

		// DependencyContext loaded from <project>/obj/project.assets.json contains all the necessary packages and assemblies
		// used by the project. However this naturally does not contain information about assemblies generated by project itself
		// (because they become available only after build).

		// This means that we use different DependencyContext for "package" libraries and "project" libraries.

		if (compilationLibrary?.Type == "package")
		{
			if (_projectAssetLoadInfo.TryLoadAssembly(compilationLibrary, out Assembly assembly))
			{
				return assembly;
			}
		}

		if (compilationLibrary?.Type == "project")
		{
			compilationLibrary = _buildLoadInfo.FindCompilationLibrary(assemblyName);
			if (compilationLibrary != null) // pokud je DisableTransitiveProjectReferences=true, pak nemusí být projekt v *.deps.json!
			{
				if (_buildLoadInfo.TryLoadAssembly(compilationLibrary, out Assembly assembly))
				{
					return assembly;
				}
			}
		}

		return null;
	}

	private class DependencyLoadInfo
	{
		public DependencyContext DependencyContext { get; }

		public ICompilationAssemblyResolver CompilationAssemblyResolver { get; }

		public DependencyLoadInfo(DependencyContext dependencyContext, string appBasePath)
		{
			DependencyContext = dependencyContext;
			CompilationAssemblyResolver = new AssemblyPathFixingCompilationAssemblyResolverFactory(appBasePath).Create(dependencyContext);
		}

		public CompilationLibrary FindCompilationLibrary(AssemblyName assemblyName)
		{
			return DependencyContext.CompileLibraries.FirstOrDefault(l => l.Name == assemblyName.Name);
		}

		public bool TryLoadAssembly(CompilationLibrary library, out Assembly assembly)
		{
			string[] paths = library.ResolveReferencePaths(CompilationAssemblyResolver).ToArray();
			assembly = paths.Where(File.Exists)
				.Select(Assembly.LoadFrom)
				.FirstOrDefault();

			return assembly != null;
		}
	}
}